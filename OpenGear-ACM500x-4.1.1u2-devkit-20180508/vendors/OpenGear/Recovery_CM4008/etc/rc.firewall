#!/bin/sh

source /etc/scripts/mutex

IPTABLES="/bin/iptables"

FAILOVER_INTERFACE=$(config -g config.interfaces.wan.failover.interface | cut -f2 -d' ') 
MODEL=`cut -f1 -d' ' /etc/version  | cut -f2 -d'/' | tr '[A-Z]' '[a-z]'`

if [ "$MODEL" = "im4004" ]; then
	OOB_IP=$(ifconfig eth1.3 2> /dev/null | grep inet\ addr | cut -f2 -d':' | cut -f1 -d' ')
	WAN_IP=$(ifconfig eth1.2 2> /dev/null | grep inet\ addr | cut -f2 -d':' | cut -f1 -d' ')
	WAN_INTERFACE=eth1.2
else
	OOB_IP=$(ifconfig eth1:0 2> /dev/null | grep inet\ addr | cut -f2 -d':' | cut -f1 -d' ')
	WAN_IP=$(ifconfig eth1 2> /dev/null | grep inet\ addr | cut -f2 -d':' | cut -f1 -d' ')
	WAN_INTERFACE=eth1
fi
export WAN_INTERFACE

# Check if the WAN (well really the managment lan) is configured as failover.
# If it is, we need to make sure it jumps to the OobInput chain, rather than the WAN chain
if [ "${FAILOVER_INTERFACE}" = "${WAN_INTERFACE}" ]; then
    OOB_IP=${WAN_IP}
    WAN_IP=""
fi

# Chain names
WAN_IN=WanInput
LAN_IN=LanInput
OOB_IN=OobInput
LBK_IN=LoopInput
DYNADDR_IN=DynAddrInput
VPNFORWARD=VpnForward
BLOCK=Block
DHCPC=DhcpClient
SERVICES=Services
SERIAL=Serial
SERIALNAT=SerialNat
SSHSERIAL=SSHSerial
SSHSERIALNAT=SSHSerialNat
CASCADE=Cascade
CASCADENAT=CascadeNat
CASCADEMASQ=CascadeMasq
SDT=SDT
NAGIOS=Nagios
UPS=Ups
IPSEC=Ipsec
IPSECFORWARD=IpsecForward
OPENVPN=OpenVPN
OPENVPNFORWARD=OpenVPNForward
CMS=Cms
SSHFORWARDS=SshForwards

# Make chain names available to child scripts
export WAN_IN
export LAN_IN
export OOB_IN
export LBK_IN
export DYNADDR_IN
export BLOCK
export DHCPC
export SERVICES
export SERIAL
export SERIALNAT
export SSHSERIAL
export SSHSERIALNAT
export CASCADE
export CASCADENAT
export CASCADEMASQ
export SDT
export NAGIOS
export UPS
export IPSEC
export IPSECFORWARD
export OPENVPN
export OPENVPNFORWARD
export CMS
export SSHFORWARDS

# Script paths
CUSTOMFILE=/etc/config/filter-custom
SERVICESFILE=/etc/config/filter-services
SERIALFILE=/etc/config/filter-serial
SSHSERIALFILE=/etc/config/filter-serial-ssh
CASCADEFILE=/etc/config/filter-cascade
NAGIOSFILE=/etc/config/filter-nagios
UPSFILE=/etc/config/filter-ups
IPSECFILE=/etc/config/filter-ipsec
IPSECFORWARDFILE=/etc/config/filter-ipsec-forward
OPENVPNFILE=/etc/config/filter-openvpn
OPENVPNFORWARDFILE=/etc/config/filter-openvpn-forward
CMSFILE=/etc/config/filter-cms
SSHFORWARDSFILE=/etc/config/filter-sshforwards

INITIALIZED="/var/run/.$(basename $0)_initialized"

# Run custom rules and exit if user script exists
if [ -f ${CUSTOMFILE} ]; then
	. ${CUSTOMFILE}
	exit 0
fi

# Create  a logging deny rule for use by other chains (Do not log broadcast packets).
${IPTABLES} -n -L ${BLOCK} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${BLOCK}
	${IPTABLES} -A ${BLOCK} ! --destination 0.0.0.255/0.0.0.255 -j LOG --log-prefix "iptables: ${BLOCK}: " --match limit
	${IPTABLES} -A ${BLOCK} --protocol tcp -j REJECT --reject-with tcp-reset
	${IPTABLES} -A ${BLOCK} --protocol udp -j REJECT --reject-with icmp-port-unreachable
	${IPTABLES} -A ${BLOCK} -j DROP
fi

# DHCP client
${IPTABLES} -n -L ${DHCPC} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${DHCPC}
	${IPTABLES} -A ${DHCPC} --protocol udp --sport 67 --dport 68 -j ACCEPT
fi

# loopback rules
${IPTABLES} -n -L ${LBK_IN} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${LBK_IN}
	${IPTABLES} -A ${LBK_IN} --match state --state NEW,ESTABLISHED,RELATED -j ACCEPT
fi

# WAN rules
${IPTABLES} -n -L ${WAN_IN} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${WAN_IN}
	${IPTABLES} -A ${WAN_IN} --match state --state ESTABLISHED,RELATED -j ACCEPT
	${IPTABLES} -A ${WAN_IN} -j ${DHCPC}
fi

# LAN rules (The same as WAN for all intents)
${IPTABLES} -n -L ${LAN_IN} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${LAN_IN}
	${IPTABLES} -A ${LAN_IN} -j ${WAN_IN}
fi

# OOB rules
${IPTABLES} -n -L ${OOB_IN} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${OOB_IN}
	${IPTABLES} -A ${OOB_IN} --match state --state ESTABLISHED,RELATED -j ACCEPT
	${IPTABLES} -A ${OOB_IN} ! --in-interface dialout+ -j ${DHCPC}
	${IPTABLES} -A ${OOB_IN} --protocol tcp --destination-port 22 -j ACCEPT
	${IPTABLES} -A ${OOB_IN} --protocol tcp --destination-port 443 -j ACCEPT
	${IPTABLES} -A ${OOB_IN} -j ${BLOCK}
fi

# VPN rules
${IPTABLES} -n -L ${VPNFORWARD} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${VPNFORWARD}
fi

# SDT rules
${IPTABLES} -n -L ${SDT} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${SDT}
fi

# Dynamic INPUT rules that match by address
${IPTABLES} -n -L ${DYNADDR_IN} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${DYNADDR_IN}
fi

# Cascade rules
${IPTABLES} -n -L ${CASCADE} >& /dev/null
if [ $? != 0 ]; then
	${IPTABLES} -N ${CASCADE}
fi

# Rules for built in chains
if [ ! -f "$INITIALIZED" ]; then

	# Default policies for built in chains
	${IPTABLES} --policy FORWARD DROP
	${IPTABLES} --policy INPUT DROP
	${IPTABLES} --policy OUTPUT ACCEPT

	${IPTABLES} -A OUTPUT --out-interface lo -j ACCEPT

	# Setup FORWARD to connection track, and allow SDT and bridged packets
	${IPTABLES} -A FORWARD --match state --state ESTABLISHED,RELATED -j ACCEPT
	${IPTABLES} -A FORWARD --in-interface br0+ --out-interface br0+ -j ACCEPT
	${IPTABLES} -A FORWARD --in-interface ipsec+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD --out-interface ipsec+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD --in-interface tap+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD --out-interface tap+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD --in-interface tun+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD --out-interface tun+ -j ${VPNFORWARD}
	${IPTABLES} -A FORWARD -j ${SDT}
	${IPTABLES} -A FORWARD -j ${CASCADE}

	${IPTABLES} -A INPUT --in-interface lo -j ${LBK_IN}
	${IPTABLES} -A INPUT --in-interface br0+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface eth0+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface wlan0+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface ppp+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface ipsec+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface tap+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface tun+ -j ${LAN_IN}
	${IPTABLES} -A INPUT --in-interface dialout+ -j ${OOB_IN}
	${IPTABLES} -A INPUT -j ${DYNADDR_IN}

	# Block any packets not explicitly allowed in
	${IPTABLES} -A FORWARD -j ${BLOCK}
	${IPTABLES} -A INPUT -j ${BLOCK}

	# Static chains for cascaded serial port network port forwarding
	${IPTABLES} -t nat -N ${CASCADENAT}
	${IPTABLES} -t nat -A PREROUTING -p tcp -j ${CASCADENAT}
	${IPTABLES} -t nat -A OUTPUT -d 127.0.0.1 -p tcp -j ${CASCADENAT}
	${IPTABLES} -t nat -N ${CASCADEMASQ}
	${IPTABLES} -t nat -A POSTROUTING -p tcp -j ${CASCADEMASQ}

	# Enable IP forwarding between network interfaces
	echo 1 > /proc/sys/net/ipv4/ip_forward

	touch "$INITIALIZED"
fi

# Always regenerate rules that match by IP address
${IPTABLES} -t nat -F ${CASCADENAT} 
${IPTABLES} -t nat -F ${CASCADEMASQ} 
${IPTABLES} -F ${CASCADE}
${IPTABLES} -F ${DYNADDR_IN}

if [ ! -z "${WAN_IP}" ]; then
	${IPTABLES} -A ${DYNADDR_IN} --destination ${WAN_IP} -j ${WAN_IN}
fi
if [ ! -z "${OOB_IP}" ]; then
	${IPTABLES} -A ${DYNADDR_IN} --destination ${OOB_IP} -j ${OOB_IN}
fi

if [ -f ${CASCADEFILE} ]; then
	. ${CASCADEFILE}
fi

# Explicitly allow configured system services.
if [ -f ${SERVICESFILE} ]; then
	${IPTABLES} -n -L ${SERVICES} >& /dev/null
	if [ $? != 0 ]; then
		. ${SERVICESFILE}
	fi
fi

# Explicitly allow access to serial port services.
if [ -f ${SERIALFILE} ]; then
	${IPTABLES} -n -L ${SERIAL} >& /dev/null
	if [ $? != 0 ]; then
    		. ${SERIALFILE}
	fi
fi

# IPsec daemon
if [ -f ${IPSECFILE} ]; then
	${IPTABLES} -n -L ${IPSEC} >& /dev/null
	if [ $? != 0 ]; then
		. ${IPSECFILE}
	fi
fi

# IPsec private networking
if [ -f ${IPSECFORWARDFILE} ]; then
	${IPTABLES} -n -L ${IPSECFORWARD} >& /dev/null
	if [ $? != 0 ]; then
		. ${IPSECFORWARDFILE}
	fi
fi

# OpenVPN
if [ -f ${OPENVPNFILE} ]; then
	${IPTABLES} -n -L ${OPENVPN} >& /dev/null
	if [ $? != 0 ]; then
		. ${OPENVPNFILE}
	fi
fi

# OpenVPN private networking
if [ -f ${OPENVPNFORWARDFILE} ]; then
	${IPTABLES} -n -L ${OPENVPNFORWARD} >& /dev/null
	if [ $? != 0 ]; then
		. ${OPENVPNFORWARDFILE}
	fi
fi

# SSH serial port services.
if [ -f ${SSHSERIALFILE} ]; then
	${IPTABLES} -n -L ${SSHSERIAL} >& /dev/null
	if [ $? != 0 ]; then
		. ${SSHSERIALFILE}
	fi
fi

# Explicitly allow access to nrpe daemon.
if [ -f ${NAGIOSFILE} ]; then
	${IPTABLES} -n -L ${NAGIOS} >& /dev/null
	if [ $? != 0 ]; then
    		. ${NAGIOSFILE}
	fi
fi

# Explicitly allow access to upsd daemon.
if [ -f ${UPSFILE} ]; then
	${IPTABLES} -n -L ${UPS} >& /dev/null
	if [ $? != 0 ]; then
    		. ${UPSFILE}
	fi
fi

# Explicitly allow access to CMS forwarded SSH ports.
if [ -f ${CMSFILE} ]; then
	${IPTABLES} -n -L ${CMS} >& /dev/null
	if [ $? != 0 ]; then
    		. ${CMSFILE}
	fi
fi

# Explicitly allow access to SSH forwarded ports.
if [ -f ${SSHFORWARDSFILE} ]; then
	${IPTABLES} -n -L ${SSHFORWARDS} >& /dev/null
	if [ $? != 0 ]; then
    		. ${SSHFORWARDSFILE}
	fi
fi

#
# Set up IPv6 firewall
#
if [ -f /etc/rc.firewall6 ]; then
	/bin/sh /etc/rc.firewall6
fi
