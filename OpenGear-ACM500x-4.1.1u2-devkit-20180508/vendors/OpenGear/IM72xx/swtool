#!/bin/sh
#
# Send commands to Link Street M88E6390 switches.
# This script is used for controlling the 309063 sub-board in
# IM7216-2-24E products.
#
# bus----switch[3]
#             +---reg[32]
#             +---phy
#             |     +---reg[32]
#             +---serdes[]
#                   +---reg[32]
#
#

# Select the MDIO bus driver used to contact the switch's MDIO bus.
# This must match the bus connection physically selected by jumpers J7..J12
#   bus = "orion-mdio-mii"        -- J8,J11 (translated 1v8 - 3v3)
#   bus = "0000:06:00.0-153"      -- no jumpers, wire up igb test points :(
#   bus = "gpio-0"                -- J9,J12

BUS="gpio-0"

# Print verbose messages
verbose=
verbose_printf () {
	if [ $verbose ]; then printf "$@" >&2; fi
	true
}

# Test when argument is non-zero
nz () { [ 0 -ne "$1" ]; }
zero () { [ 0 -eq "$1" ]; }

# bitmath() updates variable $var converting it from an expression like
# "[hi:lo]=n" to an integer value. This is intended to allow "writing"
# register values using a read-clr-set-write expression.
# For example, writing the value "[2:1]=3" to a register when the reg's
# old value was 8 will result in writing 11 into the reg. (Because bitmath
# computes '8 & ~6 | 3<<1' where 6 is the mask for bits [2:1]).
#
#  [n]                     treated the same as [n:n]
#  [m:n]=v [o:p]=w ...     chain with spaces
#
bitmath () { # var $oldval
	local lo hi exp n x _val=$2
	for exp in ${!1}; do
	    case $exp in 
	        "["*"]="*)
		    n=${exp#*]=}
		    x=${exp#[};
		    x=${x%%]=*}
		    case $x in
			*:*) hi=${x%:*} lo=${x#*:};;
			*)   let hi=x lo=x;;
		    esac
		    if [ $lo -gt $hi ]; then
			let x=lo lo=hi hi=x
			echo "${!1}: corrected bit range to [$hi:$lo]" >&2
		    fi
		    let _val=$((_val & ~( (1<<(hi+1) )-(1<<lo) ) | n<<lo))
		    ;;
		*)  let _val=$exp
		    ;;
	    esac
	done
        verbose_printf "%s -> 0x%04x\n" "${!1}" $_val
	let $1=_val
}

is_bitmath () { #var
	case ${!1} in
	    "["* | *" ["*) true;;
	    *)             false;;
	esac
}

bus_filename () {
	# Returns path to an MDIO bus virtual inode. e.g. Writes to the file
	# are converted into bus write operations to store into the register.
	local addr=$1 reg=$2
	printf "%s:%02x/%d" "/sys/class/mdio_bus/$BUS/device/$BUS" $addr $reg
}

bus_read () {
	# Reads an SMI register from a device on the MDIO bus
	local var=$1 addr=$2 reg=$3
	read $var <$(bus_filename $addr $reg) || return
	verbose_printf 'r 0x%04x:%d -> 0x%04x\n' $addr $reg ${!var}
}

bus_write () {
	# Writes to an SMI register on a device on the MDIO bus
	local addr=$1 reg=$2 val=$3
	verbose_printf 'w 0x%04x -> 0x%04x:%d\n' $val $addr $reg
	printf '0x%04x\n' $val >$(bus_filename $addr $reg)
}

# Each 88E639x switch on the MDIO bus has an SMI address depending on its
# ADDR[4:0] pins/strapping. Only two SMI registers are accessible, 0 and 1.
#
#    00 SMI Command Register
#       [15]    SMIBusy - host sets 1 to start, device clears on completion
#       [12]    SMIMode - 1=generate IEEE 802.3 clause 22 SMI frames; 0=don't
#       [11:10] SMIOp   - 0=rsvd; 1=write data; 2=read data; 3=rsvd
#       [9:5]   DevAddr - selects the (clause 22) device address during SMI op
#       [4:0]   RegAddr - selects the (clause 22) reg address during SMI op
#    01 SMI Data Register
#       [15:0]  SMIData - host sets this before starting a write
#                         device sets this before completing a read
#
# Valid DevAddr values on a switch are:
#    00..0a   port registers     (see 8.3.1 in Functional Spec)
#    1b       Global1 registers
#    1c       Global2 registers  (used for chained SMI operations)
#    1e       internal CPU
#    1f       TCAM
#
# Port registers:    | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
#    00 PortStatus   |  Pause  |  - | PD |   Port's mode     | DF | EE | FlowCtl |     Config Mode   |
#    01 PhysicalCtrl | RGMII   | FS | AS | PM | -  |    Force link, speed, duplex, EEE               |
#    02 FlowCtrl     |  U |                       Pointer    |           Flow Ctrl Data              |
#    03 SwitchId     |                   Product Number                          |    Revision       |
#    04 PortCtrl     | SAFilt  | EH Mode |  H |  S |FrameMode| VT | TiB,Init Pri | EFloods |  PState |
#    05 PortCtrl1    | MP | LP | VP |        LAG ID          |               FID[11:14]              |
#    06 VlanMap      | FID[3:0]     | FM |                           VLANTable                       |
#    07 VlanDef      | DefFPRI | FV |                              DefaultVID                        |
#    08 PortCtrl2    | FG | AB |JumboMode|  QMode  | DT | DU | MD | AM | EM | IM | AO |    DefQPri   |
#    09 EgressRate   |         -         |  Overead Offset   |  - |          Egress Dec              |
#    0a EgressRate2  |CountMode|                           Egress Rate                               |
#    0b PortAssoc    | H1 | OI | LP | IW | RL |                      PAV                             |
#    0c ATUCtrl      | RC | LR | OI | KO |    -    |        LearnLimit/LearnCtr                      |
#    0d Override     | DAPriOv | SAPriOv |VTUPriOv |MissMirro| Miss Traps        |    -    | TCAMMode|
#    0e PolicyCtrl   | DAPolcy | SAPolcy |VTUPolcy |ETypePlcy|PPPoEPlcy|VBASPlcy |Opt82Plcy| UDPPlcy |
#    0f PortEther    |                                 PortEType                                     |
#    16 LEDCtrl      |  U | Pointer      | -  |                                       LED Data       |
#    17 IPPrioMap    |  U |           Pointer           |IPY | DIQ|    IP_QPRI    |DIF |  IP_FPRI    |
#    18 IEEEPrioMap  |  U |    Table     |    Pointer   |                  Data                      |
#    19 PortCtrl3    |                            -                    | UD |  - | ED | EC |UDY |UCY |
#    1b QueueCnt     |    Mode           | SI |    -    |          OutQ sizes and data               |
#    1c QueueCtrl    |  U |          Pointer                 |              Queue Data               |
#    1e CutThruCtrl  |  EnableSelect     |        -     | CE |      Cut Through Queue                |
#    1f DebugCnt     | RxBad/TxCollision Counter             |        RxGood/TxTransmit              |
#                    | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |

switch_wait () {
	local switch=$1 r
	local timeout=50
	while bus_read r $switch 0  &&  nz $((r & 0x8000)); do
	    let timeout=timeout-1
	    if [ $timeout -eq 0 ]; then
	       echo "sw$switch: busy timeout" >&2
	       return 1
	    fi
	done
}

switch_read () {
	# Perform an SMI read operation on the switch
	local var=$1 switch=$2 dev=$3 reg=$4
	bus_write $switch 0 $((0x9800 | dev << 5 | reg)) &&
	switch_wait $switch &&
	bus_read $var $switch 1
}

switch_write () {
	local switch=$1 dev=$2 reg=$3 val=$4 oval
	if is_bitmath val; then
	   switch_read oval $switch $dev $reg && bitmath val $oval
	fi &&
	bus_write $switch 1 $val &&
	bus_write $switch 0 $((0x9400 | dev << 5 | reg)) &&
	switch_wait $switch
}

# Each switch's EEPROM is accessed though Global2 regs 0x14,0x15

# The internal PHYs for each port (and the two SERDES ports)
# have registers accessed indirectly through the switch's "Global2"
# registers 0x18,0x19:
#    18 SMIPhyCmd
#       [15]    Busy
#       [14:13] SmiFunc
#       [12]    SmiMode
#       [11:10] SmiOp
#       [9:5]   DevAddr
#       [4:0]   RegAddr
#    19 SmiPhyData
#       [15:0]  Data
#
# The internal Port 1..8 PHYs are mapped at SMIPhy device addresses 1..8
# The internal SERDES registers are mapped at SMIPhy device addresses 9,10
# These are documented in phy and MV-S110662-00
# ("88E6390X et al PHY and SERDES Functional Specification")
#
# The PHY registers are paged. There are 8 pages of 32 x 16-bit PHY registers.
# Register 0x16 (22) holds the current page and is shared over all pages.
#
#    16 PageAddress
#       [15:8] Reserved (0)
#       [7:0]  Page number   (retained on soft reset)

phy_wait () {
	local switch=$1 r
	while switch_read r $switch 0x1c 0x18  &&  nz $((r & 0x8000))
	do :; done
}

# Handle register names of form <reg>_<page>
_phy_page () {
	local page
	case $reg in
	   # if $reg ends with _<page>, issue a page request
	   # by writing to register 22_*, then cut the _<page> suffix
	   # from $reg.
	   *_*) page=${reg#*_} reg=${reg%_*}
	        switch_write $switch 0x1c 0x19 $page && # 22 is page register
	        switch_write $switch 0x1c 0x18 $((0x9400 | port << 5 | 22)) &&
		phy_wait $switch
		;;
	esac
}

phy_read () {
	local var=$1 switch=$2 port=$3 reg=$4
	_phy_page &&
	switch_write $switch 0x1c 0x18 $((0x9800 | port << 5 | reg)) &&
	phy_wait $switch &&
	switch_read $var $switch 0x1c 0x19
}

phy_write () {
	local switch=$1 port=$2 reg=$3 val=$4 oval
	_phy_page &&
	if is_bitmath val; then
	   phy_read oval $switch $port $reg && bitmath val $oval
	fi &&
	switch_write $switch 0x1c 0x19 $val &&
	switch_write $switch 0x1c 0x18 $((0x9400 | port << 5 | reg)) &&
	phy_wait $switch
}

# The SERDES registers are mapped at SMIPhy device addresses 9,10.
# Where documentation refers to "Device 4", replace that with 9 or 10.
#

serdes_read () {
	local var=$1 switch=$2 port=$3 device=$4 reg=$5
	switch_write $switch 0x1c 0x19 $reg &&
	switch_write $switch 0x1c 0x18 $((0x8000 | port << 5 | device)) &&
	switch_write $switch 0x1c 0x18 $((0x8800 | port << 5 | device)) &&
	switch_read $var $switch 0x1c 0x19
}

serdes_write () {
	local switch=$1 port=$2 device=$3 reg=$4 val=$5 oval
	if is_bitmath val; then
	   serdes_read oval $switch $port $device $reg && bitmath val $oval
	fi &&
	switch_write $switch 0x1c 0x19 $reg &&
	switch_write $switch 0x1c 0x18 $((0x8000 | port << 5 | device)) &&
	switch_write $switch 0x1c 0x19 $val &&
	switch_write $switch 0x1c 0x18 $((0x8400 | port << 5 | device))
}

sel () { # i val0 val1 val2...
	shift $(($1 + 1))
	echo "$1"
}

testbit () {
	local n=$1 bit=$2
	nz $(( n >> bit & 1 ))
}

# Dump status for diagnostics
diag () {
	local switch port
	local internal=

	echo "IM7216-2-24E diagnostics"

	# -i: show inter-switch links
	case $1 in -i) internal=1; shift;; esac

	if [ ! -d /sys/class/mdio_bus/$BUS ]; then
	  # no bus: diagnose bus driver attachment
	  dmesg | sed -n '/309063:/s,[^]]*] ,,p' 
	  lspci -s 05:00 | grep . || echo "05:00   (missing)"
	  lspci -s 06:00 | grep . || echo "06:00   (missing)"
	  echo "error: mdio bus '$BUS' was not found" >&2
	  echo "diag: check 309063 sub-board installed" >&2
	  echo "diag: check interconnect to 309063 sub-board" >&2
	  echo "diag: check PCIe lane malfunction" >&2
	  return 1
	fi

	if ! ls -d1 /sys/class/mdio_bus/$BUS/device/$BUS:* >/dev/null 2>&1
	then
	   # no devices on bus: diagnose bus
	   echo "error: no PHYs detected on mdio bus '$BUS'" >&2
	   echo "diag: check jumper settings" >&2
	   echo "diag: check noise on MDIO bus" >&2
	   echo "diag: check UART MPIO malfunction" >&2
	   echo "diag: check MDIO buffer malfunction" >&2
	   # show the MPIO state, which can be helpful
	   if grep -q /sys/kernel/debug /proc/mounts ||
	      mount -t debugfs - /sys/kernel/debug; then
	        sed -n '/^GPIOs 208-239/,/^$/p' /sys/kernel/debug/gpio >&2
	   fi
	   return 1
	fi

	for switch in 4 2 3; do
	  local sw=$((switch == 4 ? 0 : switch - 1))
	  local rid

	  if [ ! -d /sys/class/mdio_bus/$BUS/device/$BUS:0$switch ]; then
	    echo "error: mvl88 switch $switch not probed" >&2
	    echo "diag: check for switch malfunction" >&2
	    continue
	  fi

	  if ! switch_read rid $switch 30 3; then
	    echo "error: mvl88 switch $switch not responding" >&2
	    echo "diag: check for switch malfunction" >&2
	    continue
	  fi

	  if [ $internal ]; then
	    local product
	    case $((rid >> 4)) in
		161) product="Marvell 88E6390X";;
		912) product="Marvell 88E6390";;
		160) product="Marvell 88E6190X";;
		400) product="Marvell 88E6190";;
		*)   product="<unknown #$((rid >> 4))>";;
	    esac
	    product="$product rev $((rid & 15))"
	    echo "$BUS:$switch: found $product"
	  fi

	  local gc2; switch_read gc2 $switch 0x1b 0x1c  # Global Control 2
	  local ctrmode=$((gc2 >> 5 & 1))  # 0=rxbad/rxgood 1=collis/tx

	  for port in 0 1 2 3 4 5 6 7 8 9 10 30; do
	    local name="sw${sw}p$port"
	    if [ $port -gt 0 -a $port -lt 9 ]; then
	        name="$name [$(( sw * 8 + port ))]"
	    elif ! [ $internal ]; then
	        continue
	    fi

	    # PortStatus register
	    local rstatus; switch_read rstatus $switch $port 0 || continue

	    # PortControl register
	    local rctrl; switch_read rctrl $switch $port 4 || continue
	    local portstate=$(sel $((rctrl & 3)) disabled listening learning)

	    local mode=
	    if [ $internal ]; then
	      case $((rstatus & 7)):$((rstatus >> 12 & 1)) in # Config mode
	         0:?) mode="FD MII";;
		 1:?) mode="MII PHY";;
		 2:0) mode="MII MAC";;
		 2:1) mode="MII to PHY";;
		 3:?) mode="GMII";;
		 4:0) mode="RMII PHY";;
		 4:1) mode="RMII to PHY";;
		 5:0) mode="RMII MAC";;
		 5:1) mode="RMII to PHY";;
		 6:?) mode="xMII tristate";;
		 7:0) mode="RGMII";;
		 7:1) mode="RGMII to PHY";;
		 9:0) mode="1000BASE-X";;
		10:1) mode="SGMII";;
		11:?) mode="2500BASE-X";;
		12:?) mode="10Gb-XAUI";;
		13:?) mode="10Gb-RXAUI";;
		15:1) mode="PHY";;
		   *) mode="<$((rstatus & 7)):$((rstatus >> 12 & 1))>";;
	      esac
	    fi
	    if zero $((rstatus >> 11 & 1)); then # Link?
	        echo "$name: ${mode:+$mode, }no link${portstate:+, $portstate}"
		continue
	    fi
	    echo -n "$name: ${mode:+$mode, }link${portstate:+, $portstate}"

	    local speed=$(sel $((rstatus >> 8 & 3)) 10 100 1000 2500)" Mb/s"
	    echo -n ", $speed"

	    local duplex=$(sel $((rstatus >> 10 & 1)) half-duplex full-duplex)
	    local autofixed=$(sel $((rstatus >> 7 & 1)) "" " autofixed")
	    local eee=$(sel $((rstatus >> 6 & 1)) "" " eee")
	    local txpause=$(sel $((rstatus >> 5 & 1)) "" " tx-paused")
	    local fc=$(sel $((rstatus >> 4 & 1)) "" " fc")

	    echo -n ", $duplex$autofixed$eee$txpause$fc"

	    local fm=$((rctrl >> 8 & 3)) # Frame mode
	    if nz $fm; then
	       echo -n ", frame $(sel $fm "" DSA Provider "eth-DSA")"
	       echo -n "$(sel $((rctrl >> 12 & 3)) "" " untag" " tag")"
	    fi

	    # Port Control 2
	    #local pc2; switch_read pc2 $switch $port 8 || continue
	    #local jumbo=$((pc2 >> 12 & 3))

	    # Debug Counter
	    local dbg_cnt; switch_read dbg_cnt $switch $port 0x1f || continue
	    case $ctrmode in
	    0) echo -n ", rxbad $((dbg_cnt >> 8)) rxgood $((dbg_cnt &0xff))";;
	    1) echo -n ", txcoll $((dbg_cnt >> 8)) txcnt $((dbg_cnt &0xff))";;
	    esac

	    echo
	  done
	done
}

case $1 in
  -v) verbose=1; shift;;
esac

cmd=$1; shift
val=
case $cmd:$# in
   read_serdes:4)       serdes_read   val "$@" && echo $val;;
   read_phy:3)          phy_read      val "$@" && echo $val;;
   read_switch:3)       switch_read   val "$@" && echo $val;;
   write_serdes:5)      serdes_write      "$@";;
   write_phy:4)         phy_write         "$@";;
   write_switch:4)      switch_write      "$@";;
   diag:?)              diag              "$@";;
   *)
	echo "\
usage: $0 [-v] read_switch  switch port        reg
       $0 [-v] write_switch switch port        reg val
       $0 [-v] read_serdes  switch port device reg
       $0 [-v] write_serdes switch port device reg val
       $0 [-v] read_phy     switch port        reg
       $0 [-v] write_phy    switch port        reg val
       $0 diag [-i]" >&2
	exit 2
	;;
esac
